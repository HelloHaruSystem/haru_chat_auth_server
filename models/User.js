/**
 * User model for Haru_chat
 * Represents a user entity
 * 
 * @module models/User
 */

/**
 *  Represents a user of haru_chat
 */
class User {
    /**
     * Constructor method
     * Creates an instance of User class
     * 
     * @param {?number} id - User id. can be null because the id will be generated by the database .
     * @param {string} username - username of the user.
     * @param {string} password - hashed password of the user.
     * @param {Date} createdAt - Account creation date.
     * @param {boolean} isBanned - Weather the user is banned or not.
     */
    constructor(id, username, password, createdAt, isBanned) {
        if (id !== null && typeof id !== "number") {
            throw new Error("id must be a number");
        }
        this._id = id;

        if (typeof username !== "string" || username.trim() === "") {
            throw new Error("username must be a string and not empty");
        }
        this._username = username;

        if (typeof password !== "string" || password.trim() === "") {
            throw new Error("password can't be empty");
        }
        this._password = password; // this will be hashed before storage

        if (!(createdAt instanceof Date)) {
            throw new Error("createdAt must be a Date object");
        }
        this._createdAt = createdAt;

        if (typeof isBanned !== "boolean") {
            throw new Error("isBanned must be a boolean");
        }
        this._isBanned = isBanned;

        this._roles = [];
    }

    /**
     * Get method for ID
     * 
     * @returns {?number} User ID
     */
    getId() {
        return this._id;
    };

    /**
     * Set method for ID
     * 
     * @param {?number} id - User's ID
     * @throws {Error} If id is not of type number
     */
    setId(id) {
        if (id !== null && typeof id !== "number") {
            throw new Error("id must be a number");
        }
        this._id = id;
    };

    /**
     * Get method for username
     * 
     * @returns {string} Username
     */
    getUsername() {
        return this._username;
    };

    /**
     * Set method for username
     * 
     * @param {string} username - User's username
     * @throws {Error} If username is not of type string or is empty
     */
    setUsername(username) {
        if (typeof username !== "string" || username.trim() === "") {
            throw new Error("username must be a string and not empty");
        }
        this._username = username;
    };

    /**
     * Set method for password.
     * This should be hashed before storage
     * 
     * @param {string} password - User's password (Should be hashed before calling this method)
     */
    setPassword(password) {
        this._password = password;
    };

    /**
     * Get method createdAT
     * gets the user creation date
     * 
     * @returns {Date} Account creation date
     */
    getCreatedAt() {
        return this._createdAt;
    };

    /**
     * Get method for user ban status
     * 
     * @returns {boolean} Weather user is banned or not.
     */
    getIsBanned() {
        return this._isBanned;
    };

    /**
     * Set method for banned
     * Sets the banned status of a user
     * 
     * @param {boolean} banned - Use's Banned status
     * @throws {Error} If banned is not of type boolean
     */
    setIsBanned(banned) {
        if (typeof banned !== "boolean") {
            throw new Error("isBanned must be a boolean");
        }
        this._isBanned = banned;
    };

    /**
     * Get method for roles
     * gets a copy array of the users roles
     * 
     * @returns {string[]} A copy of the user's roles
     */
    getRoles() {
        return[...this._roles];
    };

    /**
     * Set method for roles
     * 
     * @param {string[]} roles - Sets the user's roles
     * @throws {Error} If roles is not of type Array
     */
    setRoles(roles) {
        if (!Array.isArray(roles)) {
            throw new Error("Error: roles must be of type array");
        }

        this._roles = [...roles];
    };

    /**
     *  Checks if the user has a certain role
     * 
     * @param {string} roleName  - role name to check for
     * @returns {boolean} Weather the user has that role or not
     */
    hasRole(roleName) {
        return this._roles.includes(roleName);
    };

    /**
     * Adds a role to a user E.g. "user"
     * 
     * @param {string} roleName - Name of role to add to the user
     */
    addRole(roleName) {
        if (!this._roles.includes(roleName)) {
            this._roles.push(roleName);
        }
    }

    /**
     * Returns true if the user has the admin role
     * 
     * @returns {boolean} Weather user admin or not
     */
    isAdmin() {
        return this._roles.includes("admin");
    }

    /**
     * Removes a role from the user
     * 
     * @param {string} roleName - Name of the role to remove from user
     * @throws {Error} If roleName is not of type string or empty
     */
    removeRole(roleName) {
        if (typeof roleName !== "string" || roleName.trim() === "") {
            throw new Error("Error role must be of type string and not empty");
        }

        const index = this._roles.indexOf(roleName);
        if (index !== -1) {
            this._roles.splice(index, 1);
        }
    };

    /**
     * Returns a safe, serializable version of the user without the password
     * 
     * @returns {{id: number|null, username: string, createdAt: Date, isBanned: boolean, roles: string[]}}
     */
    getSafeObject() {
        return {
            id: this._id,
            username: this._username,
            createdAt: this._createdAt,
            isBanned: this._isBanned,
            roles: this.getRoles()
        };
    };
};

export { User };